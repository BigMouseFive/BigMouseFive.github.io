---
layout: post
title: 客户端通信
date: '2019-05-24 15:56'
categories: 
 - 工作记录
---

# 基础情况

服务器端有中心服务和消息队列服务。中心服务可以增、删、改、查Mysql数据库的内容，也可以将数据保存在中心服务进程的内存中。消息队列服务可以进行消息的订阅和分发。
客户机端上运行着客户端，每个客户端程序每次只能登录一个用户。每个客户端都会与中心服务和消息队列服务连接。
当存在上下级的情况时。中心服务的连接方式是：下级中心服务注册到上级中心服务。消息队列的连接方式是：上级中心服务向下级中心服务获取下级消息队列的地址，上级中心服务连接到下级消息队列。下级消息队列发送消息到上级中心，再由上级中心转发到上级的消息队列。

# 客户端通信需求

1. 可以多选用户发送消息
2. 可以发送消息给下级用户
3. 可以发送消息给上级用户
4. 可以查看历史消息

# 需求的实现可能性

1. 可以使用具有多选框的用户树
2. 上级客户端可以获取到所有下级中的用户，并在设备树中显示。发送消息的时候，发送到中心服务，转发到下级中心服务。
3. 下级客户端向上级中心去获取用户信息，如果上级中心服务还有上级，将接着向上转发，直到没有上级，获取所有的用户信息，然后返回。
4. 消息存储到mysql数据库中。

# 实现时要注意的

1. 存储消息时可以考虑：冷热数据+缓存。

# 通信流程

## 客户端获取所有用户

1. 向中心服务发送请求`GET /AllDomainUser`。
2. 中心服务判断是否还有上级：有，将请求转发给上级；没有，获取所有域中的用户信息。

## 中心服务获取所有域中的用户信息

1. 向所有下级中心发送请求`GET /SubDomainUser`。
2. 中心服务判断是否有下级，如果有就向所有下级发送请求`GET /SubDomainUser`，整合所有下级用户信息和本级用户信息作为响应返回给上级中心服务。

## 发送消息

1. 记录消息时间，消息内容，发送者，接收者，作为请求发送给中心服务
2. 中心服务根据请求account中的domain内容去转发给对应的上级或者下级
3. 如果接收者是本中心服务，那么将进行处理：①如果用户在线，那么通过[用户和中心服务的]TCP长连接发送消息，修改消息状态为已读并保存消息到mysql数据库中；②如果用户不在线，则保存消息[消息状态为未读]到mysql数据库中。

## 接收消息

在获取用户的时候，获取所有域中与当前这个客户端登录用户有关的所有消息。

# 设计

## 消息表设计

列：发送者id 接收者id 消息内容 消息类型 时间 消息状态

说明：

1. 消息类型有三种：文本，语音，图片。
2. 当消息类型为语音和图片时，消息内容中是URL。
3. 消息状态有两种：已读，未读。

## 数据结构设计

### 聊天消息结构

```cpp
/* 聊天消息的状态 */
#define CHATRECORD_STATUS_READ    0x0
#define CHATRECORD_STATUS_UNREAD  0x1

/* 聊天消息类型 */
#define CHATRECORD_TYPE_TEXT      0x0
#define CHATRECORD_TYPE_AUDIO     0x1
#define CHATRECORD_TYPE_IMAGE     0x2

typedef struct {
  std::string receiver;
  std::string sender;
  std::string content;
  int type;
  int status;
  long timestamp;
} ChatRecord;
```

用户池概念是否能够实现
如果消息发送失败了
级联修改建议：注册使用上下级方式，但是访问指定级时候